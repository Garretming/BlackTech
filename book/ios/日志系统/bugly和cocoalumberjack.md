bugly和CocoaLumberjack

程序猿也好、攻城狮也罢，难免要解决各种各样的bug。好定位的bug，看看代码，捋捋逻辑就解决了。让开发者头疼的是那些不好定位、难以复现、没有头绪的bug，你丫的藏那么深！此时程序猿的内心是这么想的...

6763018-61a486f4baf7ba4d.png
但事实是这样的...

6763018-a2cc567f99f57689.png
6763018-34d8bfa7723b7201.png
此刻正在看这篇文章的你，有木有同感？不扯淡了，今天就如何更好、更快、更准确地定位bug，介绍两种工具，Bugly 和 CocoaLumberjack，有了它们俩，能让开发者把bug牢牢抓在手心，想怎么捏就怎么捏！

一、Bugly 简介
Bugly，腾讯开发的用于监控崩溃的管理工具，简单实用。
下面以iOS平台为例，介绍一下Bugly的使用：
首先打开网址 https://bugly.qq.com/v2/downloads，下载iOS的SDK，里面有使用指南和demo，可参考学习，

6763018-3032fa5b0caeec02.png
然后注册登录Bugly帐号，在 “我的产品” 页面点击 “新建产品” ，选择iOS平台创建产品后，在我的产品列表 “操作” 下面点击“设置”，找到产品的 App ID，

6763018-8c01a8ff2828c699.png
6763018-821ed2747b50b849.png
用Xcode新建Demo工程，

1、Bugly的集成
Bugly有手动集成和CocoaPods集成两种方式：

CocoaPods集成，在工程的 Podfile 文件里添加 pod 'Bugly' ，然后在终端执行 pod install 即可，关于CocoaPods的使用方法请参考我的另一篇文章 《CocoaPods的安装使用》。

手动集成，把下载好的 Bugly.framework 拖拽到Xcode工程，选择 Copy items if needed 选项，或者在 Build Phases 里面直接添加即可。

6763018-6e15fa9cdb469e86.png
2、Bugly的初始化
在 AppDelegate.m 中导入 Bugly的头文件 #import <Bugly/Bugly.h> ，若是 Swift工程，要在 bridging-header.h 中导入。然后在 AppDelegate.m的 didFinishLaunchingWithOptions 方法里初始化 Bugly，这里需要把上面的 App ID 拷贝过来作为参数。

6763018-5fa778de2366afba.png
至此 Bugly 已成功添加到工程中，搞个崩溃的bug，稍等一会（Bugly上报崩溃的时间比实际崩溃发生的时间稍晚），就能在Bugly网页上监控到崩溃信息了。

6763018-906e5a70fcd95512.png
6763018-0cf4d951239d2dcf.png
6763018-77e711e210065f26.png
6763018-2ef0df03d23aeec0.png
如图中所示，在崩溃分析中，可以查看到崩溃的发生时间、发生次数、影响的用户数、设备机型和系统、Bundle ID等信息，甚至可以定位出导致崩溃的具体线程和方法，还提供了解决方案，感觉爽歪歪！

崩溃分析只是最常用的一个功能，除此外 Bugly 的功能还有卡顿监控、错误分析、产品异常概况走势图、自定义日志等，这里不再一一介绍。下面介绍另一个记录日志的工具 CocoaLumberjack，它是 Bugly 的完美搭档。

二、CocoaLumberjack 简介
CocoaLumberjack 是一个适用于 Mac和 iOS的快速、简单、灵活且功能强大的日志框架，它的其他特性我就不啰嗦了，这里主要介绍把日志写入文件的功能，开发者可以查看本地的加密日志，用于排查bug。

CocoaLumberjack 集成同样分为CocoaPods集成和手动集成两种方式。CocoaPods集成，在 Podfile文件添加 pod 'CocoaLumberjack' ，在终端执行 pod install 即可；若手动集成，下载GitHub源码，把Lumberjack文件夹拖拽到 Xcode工程中即可，注意要把 swift文件去掉，不然编译会报错。

6763018-729139e9860614d1.png
在 AppDelegate.m 的 didFinishLaunchingWithOptions 方法里添加下面这行代码，使日志打印可以输出到Xcode控制台，

6763018-e3bcf4c23735b15b.png
在 pch 文件中导入 Bugly 的头文件 #import "CocoaLumberjack.h" 并设置日志级别，

6763018-beb10a9f785e354f.png
日志级别分为5种，按级别从低到高依次为：DDLogLevelError、DDLogLevelWarning、DDLogLevelInfo、DDLogLevelDebug、DDLogLevelVerbose，高级别记录的信息包含低级别记录的所有信息，级别越高，日志信息越详细。

6763018-d1384762d2c1a49a.png
此时就可以使用 DDLogDebug 来代替 NSLog 打印了，不过 DDLogDebug 这个前缀有点长，且只会输出时间戳和工程名，信息量有限，所以为了优化日志记录，可以使用自定义宏代替 DDLogDebug。如上面的 pch 文件图中，我用 XRLog 代替 DDLogDebug ，并且扩展记录了类名和行号，格式和语法与 NSLog 一样，使用起来简单方便。

6763018-60f2b46e1c55303c.png
下面回到 AppDelegate.m 类，在 didFinishLaunchingWithOptions 方法里添加如下代码，将日志打印写入本地文件，默认路径为沙盒目录下的 Library/Caches/Logs/日志名.log，默认日志文件名为 “Bundle ID + 时间戳”。

6763018-00c6eb96cbeae25b.png
此处可设置单个日志文件的最大容量、生成新日志文件的时间周期、最多可保存的日志文件数量、硬盘最大日志存储容量（即本地所有日志文件的总大小）。如图我设置成每个日志不超过2M，本地最多存储20M，每天生成一个新日志文件，可最多保存7个日志文件（日期可以不连续）。如果没有设置这些变量，在 DDFileLogger.m 中有提供相应的默认值：

6763018-74bf17b3e17ee9dc.png
注意，并不是设置了单个日志文件最大容量为2M，就一定不会超过2M。假如本地日志文件大小为1.9M，而下次一次性要写入的日志内容大小为0.5M，这时框架判断本地日志文件未超过2M，仍然允许继续写入日志，那么写入后日志文件就变为2.4M。只有在写入日志前，判断本地日志文件已超过2M，才不再写入，而是生成一份新的日志文件。这也算是CocoaLumberjack的一个缺陷吧，想优化日志大小的控制，只能自己用代码去实现了，这里不再具体展开，只提供几个思路：

（1）在每次写入日志前，判断本地日志文件大小加上要写入的日志内容大小之和是否大于设置的单个日志最大容量，若大于，则停止写入日志；

（2）每次启动App，生成新的日志文件前，先判断本地所有的日志文件总大小是否大于设置的硬盘最大日志存储容量，若大于，则把本地所有日志文件按照生成的时间先后排序，依次删除最早期的日志文件，直到剩余的所有日志文件总大小小于设置的最大存储容量为止；

（3）可根据日期控制日志文件的存储范围，如只保留30天以内的日志文件，超过30天以上的日志文件直接删除；

到这里记录日志并写入文件的功能就已经基本实现，只要使用 XRLog 打印的内容，都会出现在Xcode控制台并写入日志文件中，所以为了更快捷地定位问题，尽可能多的在工程中插入 XRLog 打印吧，越详细越好！但注意记录的日志不要涉及用户的登录密码及隐私数据，只要记录代码的执行步骤、标记字段、接口响应情况、异常信息等，并记得要给本地存储的日志文件加密哦！开发者可通过Xcode上的Devices功能查看App的沙盒文件，进而查阅日志来定位问题。

6763018-30eee629dc7fad45.png
三、CocoaLumberjack 优化
上面介绍了开发者在开发阶段如何利用日志定位问题，但若是App用户遇到bug，总不能每次都拿着设备去找开发者吧，想要让App用户自己把日志上传到服务器，应该怎么办呢？这就涉及到不同的用户登录同一台设备，如何分别生成对应的日志文件的问题。为了解决这个问题，下面我进一步对CocoaLumberjack框架进行了优化：

首先要区分不同的用户及设备，分别记录对应的日志文件，我以“用户登录帐号＋登录日期＋登录设备号”给日志文件命名，每个帐号每一天在同一个设备只能生成一个日志文件，不同的帐号生成不同的日志文件。这里又产生了一个问题，虽然设备号和日期可以获取到，但用户的登录帐号必须登录成功后才能获取，那未登录状态下，如何记录日志呢？（未登录状态下也可能存在少量的bug）我采取的办法是未登录状态下，先生成一个临时日志文件temp.log，把日志记录到这个临时日志文件里，登录成功后，再按照“用户登录帐号＋登录日期＋登录设备号”的命名方式生成一个正式的日志文件，合并临时日志的内容到正式日志文件的末尾，再删除临时日志文件。

有了这个思路，下面对CocoaLumberjack框架进行改造：

1. 修改 DDFileLogger.h 头文件：
（1）增加 DDFileLogger 类的 block 属性；

6763018-cf7a4d3019aedbcb.png
（2）重命名 block；

6763018-143eba39360349ce.png
（3）修改 createNewLogFile 方法名，增加日志文件名的参数；

6763018-84c04ed6422dacd5.png
2. 修改 DDFileLogger.m 实现文件：
（1）修改DDFileLogger的 init 方法，获取当前要写入信息的日志文件路径；

6763018-a8b1c6dbeae3aea7.png
（2）修改 isLogFile方法，扩展名为 .log的默认是日志文件，不自动生成新日志；

6763018-ddecc6f7e47456c7.png
（3）修改createNewLogFile方法，不在框架里给日志文件命名，废弃newLogFileName方法，把日志文件名作为方法参数传入；

6763018-6d6ce1d86e64330d.png
（4）修改 currentLogFileInfo方法，区分未登录的临时日志文件，及登录后不同帐号对应的不同日志文件的逻辑；

6763018-f522cce79727b078.png
6763018-21de7a6752039416.png
（5）修改 currentLogFileHandle方法，日志信息写入文件操作，去掉判空处理；

6763018-690b8c611ab54e32.png
（6）修改 logMessage方法，写入日志前，给日志信息加密；

6763018-1729da9132d5b214.png
3. 登录类，若本地不存在登录帐号的当天日志，则生成一个新日志文件，若存在，则往该日志文件里叠加记录日志：
6763018-8adec27d0e57acf9.png
6763018-715b8255bcfdcf75.png
好了，到此，CocoaLumberjack框架优化完毕，不同的用户可以生成不同的日志，互不干扰。现在只需要在界面上设置一些日期按钮和一个上传按钮，让用户选择要上传的日志日期范围，如当天的日志、一周内的日志、该用户的本地全部日志等，然后点击上传按钮，就可以调接口把日志上传到服务器了。这样用户反馈的问题，开发者可直接查阅服务器上对应日期、对应帐号、对应设备的日志记录，来定位bug，高效率高质量！

最后，附上一张日志文件示例图：

6763018-65ecf98dac8293a4.png